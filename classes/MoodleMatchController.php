<?php
/**
 * Created by PhpStorm.
 * User: Ghostthinker
 * Date: 26.07.2018
 * Time: 11:55
 */

namespace mod_ivs;

use mod_ivs\ivs_match\question\QuestionSummary;
use mod_ivs\ivs_match\AssessmentConfig;
use mod_ivs\ivs_match\IvsMatchControllerBase;
use mod_ivs\ivs_match\exception\MatchNoConfigException;
use mod_ivs\ivs_match\exception\MatchQuestionAccessDeniedException;
use mod_ivs\ivs_match\exception\MatchQuestionException;
use mod_ivs\ivs_match\exception\MatchQuestionNotFoundException;
use mod_ivs\ivs_match\exception\MatchTakeException;
use mod_ivs\ivs_match\IIvsMatch;
use mod_ivs\ivs_match\MatchConfig;
use mod_ivs\ivs_match\MatchTake;
use mod_ivs\IvsHelper;
use mod_ivs\output\match\question_click_answer_view;
use mod_ivs\output\match\question_single_choice_answer_view;
use mod_ivs\output\match\question_text_answer_view;
use mod_ivs\settings\SettingsService;
use moodle_url;

class MoodleMatchController extends IvsMatchControllerBase implements IIvsMatch {
    protected $overlay_offset_x = 2.3;
    protected $overlay_offset_y = 4.28;

    /**
     * MoodleMatchController constructor.
     */
    public function __construct() {
        parent::__construct($this);
    }

    /**
     * Override request handle to serve to reponse in proper way
     *
     * @param $path_arguments
     * @param $method
     * @param $post_data
     * @return \mod_ivs\ivs_match\MatchResponse|void
     */
    public function handleRequest($endpoint, $path_arguments, $method, $post_data) {

        $response = parent::handleRequest($endpoint, $path_arguments, $method, $post_data); // TODO: Change the autogenerated stub

        header("Content-type: application/json; charset=utf-8");
        http_response_code($response->getStatus());
        print json_encode($response->getData());
        exit;
    }

    /**
     * Get a single match question item
     *
     * @param $question_id
     * @param bool $skip_access
     * @return array
     * @throws \mod_ivs\ivs_match\exception\MatchQuestionAccessDeniedException
     * @throws \mod_ivs\ivs_match\exception\MatchQuestionNotFoundException
     */
    public function match_question_get_db($question_id, $skip_access = false) {

        global $DB;
        $question_from_db = $DB->get_record('ivs_matchquestion', array('id' => $question_id));

        if (empty($question_from_db->id)) {
            throw new MatchQuestionNotFoundException();
        }

        return $this->recordToPlayerQuestion((array) $question_from_db);

    }

    /**
     * Get all match question items by video keyed by question_id
     *
     * @param $video_id
     * @param string $order
     * @param bool $skip_access
     * @return mixed
     * @throws \mod_ivs\ivs_match\exception\MatchQuestionAccessDeniedException
     */
    public function match_questions_get_by_video_db($video_id, $order = 'timecode', $skip_access = false) {
        global $DB;
        $questions_from_db = $DB->get_records('ivs_matchquestion', array('video_id' => $video_id));

        $questions = array();

        foreach ($questions_from_db as $question) {
            $questions[$question->id] = $this->recordToPlayerQuestion((array) $question);
        }

        return $questions;
    }

    /**
     * Get all match question items by video keyed by question_id
     *
     * @param        $video_id
     * @param string $order
     * @param bool $skip_access
     *
     * @return mixed
     * @throws \dml_exception
     */
    public function match_questions_get_by_video_db_order($video_id, $order = 'timecode', $skip_access = false) {
        global $DB;

        $sql = 'SELECT * FROM {ivs_matchquestion} mq WHERE mq.video_id = ?';
        if ($order === 'timecode') {
            //ORDER BY keyword sorts the records in ascending order by default
            $sql = 'SELECT * FROM {ivs_matchquestion} mq WHERE mq.video_id = ? ORDER BY time_stamp ASC';
        }
        $records = $DB->get_records_sql($sql, [$video_id]);

        $questions = array();
        foreach ($records as $question) {
            $questions[$question->id] = $this->recordToPlayerQuestion((array) $question);
        }
        return $questions;
    }

    /**
     * Insert a new match question into the database
     *
     * @param $video_id
     * @param $data
     * @return mixed
     * @throws \mod_ivs\ivs_match\exception\MatchQuestionAccessDeniedException
     */
    public function match_question_insert_db($video_id, $data, $skip_access = false) {


        if (!$skip_access) {
            if (!$this->hasEditAccess($video_id)) {
                throw new MatchQuestionAccessDeniedException(null, "Access denied");
            }
            //When not skipping access, always the current user to prevent uid spoofing
            global $USER;
            $data['user_id'] = $USER->id;
        }

        $record = $this->getQuestionRecordFromRequest($video_id, $data);
        $record['timecreated'] = time();
        $this->saveQuestionDB($record);

        return $this->recordToPlayerQuestion($record);

    }

    private function saveQuestionDB(&$record) {
        global $DB;

        if (empty($record['id'])) {
            $id = $DB->insert_record('ivs_matchquestion', $record, true, true);
            $record['id'] = $id;
        } else {
            $DB->update_record('ivs_matchquestion', $record, true);
        }

    }

    /**
     * Insert a new match question into the database
     *
     * @param $video_id
     * @param $data
     * @return mixed
     * @throws \mod_ivs\ivs_match\exception\MatchQuestionNotFoundException
     * @throws \mod_ivs\ivs_match\exception\MatchQuestionAccessDeniedException
     */
    public function match_question_update_db($video_id, $data, $skip_access = false) {

        global $DB;

        if (!$skip_access) {
            if (!$this->hasEditAccess($video_id)) {
                throw new MatchQuestionAccessDeniedException(null, "Access denied");
            }

        }

        $existingRecord = $DB->get_record('ivs_matchquestion', array('id' => $data['nid']));

        //cannot change this field so use it from existing question
        $data['user_id'] = $existingRecord->user_id;

        $record = $this->getQuestionRecordFromRequest($video_id, $data);
        $record['timemodified'] = time();
        $this->saveQuestionDB($record);
        return $this->recordToPlayerQuestion($record);
    }

    /**
     * Delete an exsiting match question from the database
     *
     * @param $question_id
     * @param bool $skip_access
     * @return mixed
     * @throws \mod_ivs\ivs_match\exception\MatchQuestionAccessDeniedException
     */
    public function match_question_delete_db($question_id, $skip_access = false) {

        global $DB;
        $question_from_db = $DB->get_record('ivs_matchquestion', array('id' => $question_id));

        if (!$skip_access) {
            if (!$this->hasEditAccess($question_from_db->video_id)) {
                throw new MatchQuestionAccessDeniedException(null, "Access denied");
            }
        }

        $DB->delete_records('ivs_matchanswer', array('question_id' => $question_id));
        $DB->delete_records('ivs_matchquestion', array('id' => $question_id));

    }

    /**
     * Insert a new answer for a question
     *
     * @param $video_id
     * @param $data
     *   Holds answer data and question_id as well as the user_id
     * @param null $user_id
     * @param bool $skip_access
     * @return mixed
     * @throws \mod_ivs\ivs_match\exception\MatchQuestionException
     */
    public function match_question_answer_insert_db($video_id, $data, $user_id = null, $skip_access = false) {
        global $DB, $USER;

        if (!$user_id) {

            $user_id = $USER->id;
        }

        $question_id = $data['question_id'];

        if (empty($question_id)) {
            throw new MatchQuestionNotFoundException();
        }

        $question_from_db = $DB->get_record('ivs_matchquestion', array('id' => $question_id));

        if (!$skip_access) {

            if (!$this->mayAnswerQuestion($question_from_db)) {
                throw new MatchQuestionAccessDeniedException(null, "Access denied");
            }
        }

        $record = [
                'question_id' => $question_from_db->id,
                'user_id' => $user_id,
                'data' => !empty($data['question_data']) ? serialize($data['question_data']) : serialize([]),
                'take_id' => $data['take_id'],
                'correct' => !empty($data['is_correct']),
                'timecreated' => time(),
                'timemodified' => time(),
                'evaluated' => !empty($data['is_evaluated']) ? 1 : 0,
                'score' => !empty($data['is_correct']) ? 100 : 0,
        ];

        $id = $DB->insert_record('ivs_matchanswer', $record, true, true);
        $record['id'] = $id;

        return $this->recordToPlayerAnswer((array) $record);

    }

    /**
     * Get a single answer by answer id
     *
     * @param $answer_id
     * @param bool $skip_access
     * @return mixed
     */
    public function match_question_answer_get_db($answer_id, $skip_access = false) {
        global $DB;

        $answer_from_db = $DB->get_record('ivs_matchanswer', array('id' => $answer_id));

        if (empty($answer_from_db->id)) {
            throw new MatchQuestionNotFoundException();
        }

        return $this->recordToPlayerAnswer((array) $answer_from_db);

    }

    /**
     * Get a all answers by question and students
     *
     * @param bool $skip_access
     * @return mixed
     */
    public function match_question_answers_get_by_question($question_id, $skip_access = false) {
        global $DB;

        $record = $DB->get_records('ivs_matchanswer', array(
                'question_id' => $question_id
        ));

        $answers = array();
        foreach ($record as $answer) {
            $answers[$answer->id] = $this->recordToPlayerAnswer((array) $answer);
        }
        return $answers;
    }

    /**
     * Get a single answer by question and user
     *
     * @param $question_id
     * @param $user_id
     * @param bool $skip_access
     * @return mixed
     */
    public function match_question_answer_get_by_question_and_user_db($question_id, $user_id, $skip_access = false) {
        global $DB;
        $record = $DB->get_record('ivs_matchanswer', array(
                'question_id' => $question_id,
                'user_id' => $user_id
        ));

        return $this->recordToPlayerAnswer((array) $record);
    }

    public function match_question_answers_get_by_question_and_user_db($question_id, $user_id, $skip_access = false) {
        global $DB;
        $record = $DB->get_records('ivs_matchanswer', array(
                'question_id' => $question_id,
                'user_id' => $user_id
        ));

        $answers = array();
        foreach ($record as $answer) {
            $answers[$answer->id] = $this->recordToPlayerAnswer((array) $answer);
        }
        return $answers;
    }

    public function match_question_answers_get_by_question_db($question_id, $skip_access = false) {
        global $DB;
        $record = $DB->get_records('ivs_matchanswer', array('question_id' => $question_id));

        $answers = array();
        foreach ($record as $answer) {
            $answers[$answer->id] = $this->recordToPlayerAnswer((array) $answer);
        }
        return $answers;
    }

    /**
     * Gets all necessary data for reporting
     *
     * @param $question_id
     * @param $user_id
     * @param bool $skip_access
     * @return array
     * @throws \mod_ivs\ivs_match\exception\MatchQuestionAccessDeniedException
     * @throws \mod_ivs\ivs_match\exception\MatchQuestionNotFoundException
     */
    public function match_question_answers_get_by_question_and_user_for_reporting($question_id, $user_id, $skip_access = false) {

        $record = $this->match_question_answers_get_by_question_and_user_db($question_id, $user_id, $skip_access);

        $last = array_pop($record);
        $first = array_shift($record);
        $question = $this->match_question_get_db($question_id);

        $detail = array(
                'title' => $question['title'],
                'type' => $question['type'],
                'question' => $question,
                'userData' => $question['userdata'],
                'answers' => [$first, $last]
        );

        return $detail;
    }

    /**
     * Get a collection of answers by video and user keyed by question_id
     *
     * @param $video_id
     * @param $user_id
     * @param bool $skip_access
     * @return mixed
     */
    public function match_question_answers_get_by_video_and_user_db($video_id, $user_id, $skip_access = false) {
        global $DB, $USER;

        if (!$user_id) {

            $user_id = $USER->id;
        }

        $sql = "select * from {ivs_matchanswer} mqa
              inner join {ivs_matchquestion} mq
              on mqa.question_id = mq.id
              where mq.video_id = ?
              and mqa.user_id = ?";

        $records = $DB->get_records_sql($sql, [$video_id, $user_id]);

        $answers = array();

        foreach ($records as $answer) {
            $answers[$answer->id] = $this->recordToPlayerAnswer((array) $answer);
        }

        return $answers;
    }

    /**
     * Delete a single answer by answer_id
     *
     * @param $answer_id
     * @param bool $skip_access
     * @return mixed
     */
    public function match_question_answer_delete_db($answer_id, $skip_access = false) {
        // TODO: Implement match_question_answer_delete_db() method.
    }

    /**
     * Has access to edit match questions
     *
     * @param $activity_id
     * @return bool
     * @throws \coding_exception
     */
    private function hasEditAccess($video_id) {

        $course_module = get_coursemodule_from_instance('ivs', $video_id, 0, false, MUST_EXIST);
        $context = \context_module::instance($course_module->id);

        return has_capability('mod/ivs:edit_match_questions', $context);
    }

    private function getQuestionRecordFromRequest($video_id, $post_data) {

        $record = array(
                'type' => clean_param($post_data['type'], PARAM_TEXT),
                'title' => clean_param($post_data['title'], PARAM_TEXT),
                'time_stamp' => clean_param($post_data['timestamp'], PARAM_INT),
                'duration' => clean_param($post_data['duration'], PARAM_INT),
                'question_body' => clean_param($post_data['question_body'], PARAM_TEXT),
                'video_id' => clean_param($video_id, PARAM_INT),
        );

        if (array_key_exists('user_id', $post_data)) {
            $record['user_id'] = is_null($post_data['user_id']) ? null : clean_param($post_data['user_id'], PARAM_INT);
        }

        if (!empty($post_data['nid'])) {
            $record['id'] = $post_data['nid'];
        }

        $record['type_data'] = serialize($post_data['type_data']);

        $top = clean_param($post_data['offset']['top'], PARAM_FLOAT);
        $left = clean_param($post_data['offset']['left'], PARAM_FLOAT);

        $extra_data = [
                'offset' => [
                        'top' => !empty($top) ? $top : $this->overlay_offset_y,
                        'left' => !empty($left) ? $left : $this->overlay_offset_x,
                ]
        ];

        $record['extra'] = serialize($extra_data);

        return $record;
    }

    private function recordToPlayerQuestion($record) {

        if (!empty($record['extra'])) {
            $extra_data = unserialize($record['extra']);
        } else {
            $extra_data = [
                    'offset' => [
                            'top' => $this->overlay_offset_y,
                            'left' => $this->overlay_offset_x
                    ]
            ];
        }

        $data = [
                'nid' => $record['id'],
                'title' => $record['title'],
                'question_body' => $record['question_body'],
                'video' => $record['video_id'],
                'timestamp' => $record['time_stamp'],
                'duration' => $record['duration'],
                'type' => $record['type'],
                'type_data' => unserialize($record['type_data']),
                'userdata' => \mod_ivs\IvsHelper::getUserDataForPlayer($record['user_id']),
                'offset' => $extra_data['offset']
        ];

        //08.05.2019 - 16:54 - BH Update Feedback Single Choice question form 2.x to 3.x versions
        if ($data['type'] == 'single_choice_question') {
            foreach ($data['type_data']['options'] as &$option) {
                if (array_key_exists('feedback', $option) && is_string($option['feedback'])) {
                    $option['feedback_text'] = $option['feedback'];
                    unset($option['feedback']);
                }
            }
        }

        return $data;
    }

    /**
     * Transform db to json object
     *
     * @param $record
     * @return array
     */
    private function recordToPlayerAnswer($record) {

        return [
                'id' => $record['id'],
                'user_id' => $record['user_id'],
                'is_correct' => !empty($record['correct']) ? true : false,
                'is_evaluated' => !empty($record['evaluated']) ? true : false,
                'question_data' => is_array($record['data']) ? $record['data'] : unserialize($record['data']),
                'question_id' => $record['question_id'],
                'created' => $record['timecreated'],

        ];
    }

    private function mayAnswerQuestion($question) {

        $course_module = get_coursemodule_from_instance('ivs', $question->video_id, 0, false, MUST_EXIST);
        $context = \context_module::instance($course_module->id);

        return has_capability('mod/ivs:create_match_answers', $context);
    }

    /**
     * Get a collection of answers by take
     *
     * @param $video_id
     * @param $user_id
     * @param bool $skip_access
     * @return mixed
     */
    public function match_question_answers_get_by_take($take_id, $only_latest = true, $skip_access = false) {

        if (empty($take_id) || $take_id === 'null') {
            return array();
        }

        global $DB;
        $sql = "select * from {ivs_matchanswer} mqa
              where mqa.take_id = ?";

        $records = $DB->get_records_sql($sql, [$take_id]);

        $answers = array();

        foreach ($records as $answer) {
            if ($only_latest) {
                $answers[$answer->question_id] = $this->recordToPlayerAnswer((array) $answer);
            } else {
                $answers[] = $this->recordToPlayerAnswer((array) $answer);
            }
        }

        return $answers;
    }

    /**
     * Get the Match config by video and optional context_id
     *
     * @param int $context_id
     * @param int $video_id
     * @return MatchConfig
     * @throws MatchNoConfigException
     */
    public function match_video_get_config_db($context_id, $video_id = null) {

        $mc = new MatchConfig();
        $mc->assessment_type = AssessmentConfig::ASSESSMENT_TYPE_FORMATIVE;
        $mc->rate = 100;
        $mc->attempts = 1;
        $mc->allow_repeat_answers = true;
        $mc->player_controls_enabled = true;
        $mc->show_solution = false;
        $mc->show_feedback = true;

        return $mc;

    }

    /**
     * Check access to match takes
     *
     * @param $op - view, update
     * @param MatchTake $take
     * @return mixed
     * @internal param $take_id
     */
    public function match_take_access($op, MatchTake $take) {
        // TODO: Implement match_take_access() method.
    }

    /**
     * Insert a match take in the database
     *
     * @param MatchTake $take
     * @return mixed
     */
    public function match_take_insert_db(MatchTake &$take) {
        return $this->saveTakeDB($take);
    }

    /**
     * Update a match take in the database
     *
     * @param MatchTake $take
     * @return mixed
     */
    public function match_take_update_db(MatchTake $take) {
        return $this->saveTakeDB($take);
    }

    /**
     * Update or insert a take
     *
     * @param \mod_ivs\ivs_match\MatchTake $take
     */
    private function saveTakeDB(MatchTake $take) {

        global $DB, $USER;

        if (!$take->user_id) {

            $take->user_id = $USER->id;
        }

        $db_data = (object) [
                'video_id' => $take->video_id,
                'status' => $take->status,
                'context_id' => $take->context_id,
                'user_id' => $take->user_id,
                'evaluated' => $take->evaluated,
                'score' => $take->score,
                'timecreated' => $take->created,
                'timemodified' => time(),
                'timecompleted' => $take->completed,
        ];

        if ($take->id) {
            $db_data->id = $take->id;
        }

        if (empty($db_data->id)) {
            $id = $DB->insert_record('ivs_matchtake', $db_data, true, true);
            if (empty($id)) {
                throw new MatchTakeException();
            }
            $take->id = $id;
        }
        return $take;

    }

    /**
     * Delete a match take from the database
     *
     * @param $take_id
     * @return mixed
     */
    public function match_take_delete_db($take_id) {
        global $DB;

        $DB->delete_records('ivs_matchtake', array('id' => $take_id));
    }

    /**
     * Get a match take from the database
     *
     * @param $take_id
     * @return MatchTake
     */
    public function match_take_get_db($take_id) {
        global $DB;

        $record = $DB->get_record('ivs_matchtake', array(
                'id' => $take_id,
        ));

        if ($record) {
            return $this->matchTakeFromMoodleDBRecord((array) $record);
        }
    }

    /**
     * Get all match takes by user and context
     *
     * @param $user_id
     * @param $video_id
     * @param null $context_id
     * @param array $status
     * @return MatchTake[]
     */
    public function match_takes_get_by_user_and_video_db($user_id, $video_id, $context_id, $status = []) {

        global $DB, $USER;

        if (!$user_id) {

            $user_id = $USER->id;
        }

        $records = $DB->get_records('ivs_matchtake', array(
                'video_id' => $video_id,
                'user_id' => $user_id,
                'context_id' => $context_id
        ));

        $takes = array();

        foreach ($records as $record) {
            $takes[] = $this->matchTakeFromMoodleDBRecord((array) $record);
        }

        return $takes;

    }

    private function matchTakeFromMoodleDBRecord($record) {

        $mt = new MatchTake();
        $mt->id = $record['id'];
        $mt->evaluated = $record['evaluated'];
        $mt->score = $record['score'];
        $mt->created = $record['timecreated'];
        $mt->changed = $record['timemodified'];
        $mt->context_id = $record['context_id'];
        $mt->video_id = $record['video_id'];
        $mt->user_id = $record['user_id'];
        $mt->completed = $record['timecompleted'];
        $mt->status = $record['status'];

        return $mt;
    }

    /**
     * Get the unique id of the currently acting user
     *
     * @return int
     */
    public function get_current_user_id() {
        global $USER;
        return $USER->id;

    }

    public function permission_match_question($op, $video_id, $context_id = null, $user_id = null) {
        // TODO: Implement permission_match_question() method.
    }

    /**
     * Get an array of assessment configs
     *
     * @param $user_id
     * @param $video_id
     * @param bool $include_pending
     * @return AssessmentConfig[]
     * @throws MatchNoConfigException
     */
    public function assessment_config_get_by_user_and_video($user_id, $video_id, $include_simulation = false) {


        $assessment_config = [];

        if ($this->hasEditAccess($video_id)) {

            $assConf = new AssessmentConfig();
            $assConf->context_id = null;
            $assConf->context_label = get_string("ivs_match_context_label", 'ivs');
            $assConf->matchConfig = $this->match_video_get_config_db($video_id);
            $assConf->takes_left = -1;
            $assConf->takes = [];
            $assConf->status = AssessmentConfig::TAKES_LEFT_NEW;
            $assConf->status_description = get_string("ivs_match_context_label_help", 'ivs');
            $assessment_config[] = $assConf;

        }

        $assConf = new AssessmentConfig();
        $assConf->context_id = $video_id;
        $assConf->context_label = get_string("ivs_match_config_assessment_mode_formative", 'ivs');
        $assConf->matchConfig = $this->match_video_get_config_db($video_id);
        $assConf->takes_left = 1;
        $assConf->takes = $this->match_takes_get_by_user_and_video_db($user_id, $video_id, $video_id);
        $assConf->status = AssessmentConfig::TAKES_LEFT_NEW;
        $assConf->status_description = get_string("ivs_match_config_assessment_mode_formative_help", 'ivs');

        $assessment_config[] = $assConf;

        return $assessment_config;
    }

    /**
     * Returns all videos with match enabled
     *
     * @param $videos
     * @return array
     */
    public function get_match_enabled_videos($videos) {

        $settingsController = new SettingsService();

        $match_videos = [];
        foreach ($videos as $video) {
            $activity_settings = $settingsController->getSettingsForActivity($video->id, $video->course);

            if ($activity_settings['match_question_enabled']->value) {
                $match_videos[] = $video;
            }
        }
        return $match_videos;
    }

    /**
     * Get single Choice Data for Reporting
     *
     * @param $answers
     * @param $user
     * @return array
     */
    public function getSingleChoiceReportingData($reporting_answers, $user) {

        #print_r($reporting_answers);
        $controller = new MoodleMatchController();

        foreach ($reporting_answers as $key => $answer) {

            $single_choice_data['correct'] = '-';
            $single_choice_data['last'] = '-';
            $single_choice_data['retries'] = '-';
            $single_choice_data['selected_answer'] = '-';
            $single_choice_data['last_selected_answer'] = '-';

            if ($answer['answers'][1]['user_id'] === $user->id) {

                $user_id = $user->id;
                $answers = $controller->match_question_answers_get_by_question_and_user_db($answer['question']['nid'], $user_id);
                $num_answers = count($answers);

                if ($num_answers > 0) {
                    $single_choice_data['retries'] = $num_answers - 1;

                    $last_answer = $answer['answers'][1];
                    if (!empty($answer['answers'][0])) {
                        $first_answer = $answer['answers'][0];
                    } else {
                        $first_answer = $answer['answers'][1];
                    }

                    $single_choice_data['correct'] = !empty($first_answer['is_correct']) ? 1 : 0;
                    $single_choice_data['last'] = !empty($last_answer['is_correct']) ? 1 : 0;

                }

                //first selected answer
                $single_choice_data['selected_answer'] = $this->getFirstSelectedSingleChoiceAnswer($answer);

                //last selected answer
                $single_choice_data['last_selected_answer'] = $this->getLastSelectedSingleChoiceAnswer($answer);

                break;

            }
        }

        return $single_choice_data;
    }

    /**
     * Returns index of first selected single choice answer
     *
     * @param $answer
     */
    public function getFirstSelectedSingleChoiceAnswer($answer) {

        $singe_choice_answer_index = 0;

        if (empty($answer['answers'][0])) {
            $checked_id = $answer['answers'][1]['question_data']['checked_id'];
        } else {
            $checked_id = $answer['answers'][0]['question_data']['checked_id'];
        }

        $single_choice_questions = $answer['question']['type_data']['options'];

        foreach ($single_choice_questions as $question) {
            $singe_choice_answer_index++;
            if ($question['id'] == $checked_id) {
                break;
            }

        }

        return $singe_choice_answer_index;
    }

    /**returns index of last selected single choice answer
     *
     * @param $answer
     */
    public function getLastSelectedSingleChoiceAnswer($answer) {
        $singe_choice_answer_index = 0;
        $checked_id = $answer['answers'][1]['question_data']['checked_id'];

        $single_choice_questions = $answer['question']['type_data']['options'];

        foreach ($single_choice_questions as $question) {
            $singe_choice_answer_index++;
            if ($question['id'] == $checked_id) {
                break;
            }

        }

        return $singe_choice_answer_index;
    }

    public function getMatchQuestionTitle($question) {
        return !empty($question['title']) ? $question['title'] : shorten_text($question['question_body']);
    }

    /**
     * Get question summary raw data
     *
     * @param $question
     * @param $course_students
     * @return \mod_ivs\ivs_match\question\QuestionSummary
     */
    public function getQuestionSummaryData($question, $course_students) {

        $question_summary = new QuestionSummary();

        $question_summary->question_id = $question['nid'];
        $question_summary->question_title = $question['title'];
        $question_summary->question_body = $question['question_body'];
        $question_summary->num_students_total = count($course_students);
        $question_summary->num_students_participation = 0;
        $question_summary->first_attempt_correct = 0;
        $question_summary->last_attempt_correct = 0;
        $question_summary->question_type = $question['type'];

        $answers = $this->match_question_answers_get_by_question($question['nid']);

        $user_answer_data = [];

        foreach ($answers as $answer) {

            $user_id = $answer['user_id'];

            //only student answers
            if (!array_key_exists($user_id, $course_students)) {
                continue;
            }
            if (empty($user_answer_data[$user_id])) {
                $user_answer_data[$user_id] = [
                        'first_attempt_correct' => $answer['is_correct'],
                        'last_attempt_correct' => $answer['is_correct'],
                        'num_tries' => 1
                ];
            } else {
                $user_answer_data[$user_id]['last_attempt_correct'] = $answer['is_correct'];
                $user_answer_data[$user_id]['num_tries']++;
            }
        }

        foreach ($user_answer_data as $answer_data) {
            if ($answer_data['first_attempt_correct']) {
                $question_summary->first_attempt_correct++;
            }
            if ($answer_data['last_attempt_correct']) {
                $question_summary->last_attempt_correct++;
            }
        }

        $question_summary->num_students_participation = count($user_answer_data);

        return $question_summary;
    }

    /**
     * Get question summary formated data
     *
     * @param $question
     * @param $course_students
     * @return \mod_ivs\ivs_match\question\QuestionSummary
     */
    public function getQuestionSummaryFormated($question, $course_students) {
        $question_summary = $this->getQuestionSummaryData($question, $course_students);
        $data = new \stdClass();

        $data->question_id = $question_summary->question_id;
        $data->question_title = $question_summary->question_title;
        $data->question_body = $question_summary->question_body;

        switch ($question_summary->question_type) {
            case 'text_question':
                $data->question_type = get_string('ivs_match_question_summary_question_type_text', 'ivs');
                $data->question_first_try = 'N/A';
                $data->question_last_try = 'N/A';
                break;
            case 'click_question':
                $data->question_type = get_string('ivs_match_question_summary_question_type_click', 'ivs');
                $data->question_first_try = $question_summary->num_students_participation == 0 ? '0%' :
                        round($question_summary->first_attempt_correct * 100 / $question_summary->num_students_participation, 0) .
                        '%';
                $data->question_last_try = $question_summary->num_students_participation == 0 ? '0%' :
                        round($question_summary->last_attempt_correct * 100 / $question_summary->num_students_participation, 0) .
                        '%';
                break;
            case 'single_choice_question':
                $data->question_type = get_string('ivs_match_question_summary_question_type_single', 'ivs');
                $data->question_first_try = $question_summary->num_students_participation == 0 ? '0%' :
                        round($question_summary->first_attempt_correct * 100 / $question_summary->num_students_participation, 0) .
                        '%';
                $data->question_last_try = $question_summary->num_students_participation == 0 ? '0%' :
                        round($question_summary->last_attempt_correct * 100 / $question_summary->num_students_participation, 0) .
                        '%';
                break;
        }

        $data->question_answered = $question_summary->num_students_participation . ' / ' . $question_summary->num_students_total;

        return $data;
    }

    public function getQuestionAnswersData($detailArray, $questions, $cm_id, $video_id, $course_users, $totalcount, $output) {
        $data = new \stdClass;

        $controller = $this;

        $data->id = $detailArray[0]['question']['nid'];
        $data->label = $controller->getMatchQuestionTitle($detailArray[0]['question']);
        $data->question = $detailArray[0]['question']['question_body'];
        if (strlen($detailArray[0]['question']['title']) > 0) {
            $data->question = $detailArray[0]['question']['title'] . ': ' . $data->question;
        } else {
            $data->question = $data->question;
        }

        $data->answers = [];

        //Pager
        $page = optional_param('page', 0, PARAM_INT); // Which page to show.

        if (!empty($output)) {
            $perpage = required_param('perpage', PARAM_INT); // How many per page.
        } else {
            $perpage = $totalcount;
        }

        $offset = $page * $perpage;

        //Render Replies
        $answer_users = [];
        foreach ($course_users as $key => $course_user) {
            $answer_users[] = $course_user;
        }

        $data->text_question = false;
        $data->single_choice_question = false;
        $data->click_question = false;

        for ($i = $offset; $i < $offset + $perpage; $i++) {
            if ($i == $totalcount) {
                break;
            }
            $answer = $detailArray;

            //render mustache depending on question type
            switch ($detailArray[0]['type']) {
                case 'text_question':
                    $data->question_type = get_string('ivs_match_question_summary_question_type_text', 'ivs');
                    $data->text_question = true;
                    $renderable = new question_text_answer_view($answer, $answer_users[$i]);
                    break;
                case 'click_question':
                    $data->question_type = get_string('ivs_match_question_summary_question_type_click', 'ivs');
                    $data->click_question = true;
                    $renderable = new question_click_answer_view($answer, $answer_users[$i]);
                    break;
                case 'single_choice_question':
                    $data->question_type = get_string('ivs_match_question_summary_question_type_single', 'ivs');
                    $data->single_choice_question = true;
                    $renderable = new question_single_choice_answer_view($answer, $answer_users[$i]);
                    break;
            }

            if (!empty($output)) {
                $data->answers[] = $output->render($renderable);
            } else {
                $data->answers[] = $renderable;
            }
            //Header Labels
            $data->id_label = get_string('ivs_match_question_header_id_label', 'ivs');
            $data->type_label = get_string('ivs_match_question_header_type_label', 'ivs');
            $data->title_label = get_string('ivs_match_question_header_title_label', 'ivs');
            $data->question_label = get_string('ivs_match_question_header_question_label', 'ivs');

        }
        if (!empty($output)) {
            //Render all Questions in Dropdown
            foreach ($questions as $question) {

                $label = $controller->getMatchQuestionTitle($question);

                $question_url = new moodle_url('/mod/ivs/question_answers.php?id=' . $cm_id . '&vid=' . $video_id . '&qid=' .
                        $question['nid'] . '&perpage=10');
                $selected = required_param('qid', PARAM_INT) == $question['nid'] ? 'selected' : '';
                $data->dropdown_options[] = '<option value="' . $question_url . '" ' . $selected . '>' . $label . '</option>';
            }

            //Render Pager Options in Dropdown
            $pager_url = new moodle_url('/mod/ivs/question_answers.php?id=' . $cm_id . '&vid=' . $video_id . '&qid=' . $data->id);

            if (required_param('perpage', PARAM_INT) == 10) {
                $data->pager_options[] = '<option selected value="' . $pager_url . '&perpage=10">10</option>';
                $data->pager_options[] = '<option value="' . $pager_url . '&perpage=100">100</option>';
            } else {
                $data->pager_options[] = '<option value="' . $pager_url . '&perpage=10">10</option>';
                $data->pager_options[] = '<option selected value="' . $pager_url . '&perpage=100">100</option>';
            }
        }

        //translations
        $data->name = get_string("ivs_match_question_answer_menu_label_name", 'ivs');
        $data->user_id = get_string("ivs_match_question_answer_menu_label_user_id", 'ivs');
        $data->first_text_answer = get_string("ivs_match_question_answer_menu_label_first_text_answer", 'ivs');
        $data->last_text_answer = get_string("ivs_match_question_answer_menu_label_last_text_answer", 'ivs');
        $data->elements = get_string("ivs_match_question_answer_menu_label_elements_per_page", 'ivs');
        $data->first_click_answer = get_string("ivs_match_question_answer_menu_label_first_click_answer", 'ivs');
        $data->last_click_answer = get_string("ivs_match_question_answer_menu_label_last_click_answer", 'ivs');
        $data->click_retries = get_string("ivs_match_question_answer_menu_label_click_retries", 'ivs');
        $data->first_single_choice_answer = get_string("ivs_match_question_answer_menu_label_first_single_choice_answer", 'ivs');
        $data->single_choice_retries = get_string("ivs_match_question_answer_menu_label_single_choice_retries", 'ivs');
        $data->last_single_choice_answer = get_string("ivs_match_question_answer_menu_label_last_single_choice_answer", 'ivs');
        $data->single_choice_correct = get_string("ivs_match_question_answer_menu_label_single_choice_correct", 'ivs');
        $data->single_choice_selected_answer =
                get_string("ivs_match_question_answer_menu_label_last_single_choice_selected_answer", 'ivs');

        return $data;
    }

    public function getQuestionAnswersDataSingleChoiceQuestion($answer, $course_user) {
        $data = new \stdClass;

        $user = IvsHelper::getUser($course_user->id);
        $controller = $this;

        $single_choice_data = $controller->getSingleChoiceReportingData($answer, $course_user);

        $data->fullname = $user['fullname'];
        $data->id = $course_user->id;
        $data->correct = $single_choice_data['correct'];
        $data->selected_answer = $single_choice_data['selected_answer'];
        $data->retries = $single_choice_data['retries'];
        $data->last = $single_choice_data['last'];
        $data->last_selected_answer = $single_choice_data['last_selected_answer'];

        return $data;
    }

    public function getQuestionAnswersDataClickQuestion($answer, $course_user) {
        $data = new \stdClass;

        $user = IvsHelper::getUser($course_user->id);

        $data->fullname = $user['fullname'];
        $data->id = $course_user->id;

        $controller = $this;

        foreach ($answer as $key => $value) {

            $data->first = '-';
            $data->last = '-';
            $data->retries = '-';
            if ($value['answers'][1]['user_id'] === $course_user->id) {

                $user_id = $course_user->id;
                $answers = $controller->match_question_answers_get_by_question_and_user_db($value['question']['nid'], $user_id);
                $num_answers = count($answers);

                if ($num_answers > 0) {
                    $data->retries = $num_answers - 1;

                    $last_answer = $value['answers'][1];
                    if (!empty($value['answers'][0])) {
                        $first_answer = $value['answers'][0];
                    } else {
                        $first_answer = $value['answers'][1];
                    }

                    $data->first = !empty($first_answer['is_correct']) ? 1 : 0;
                    $data->last = !empty($last_answer['is_correct']) ? 1 : 0;

                }

                break;

            }
        }

        return $data;
    }

    public function getQuestionAnswersDataTextQuestion($answer, $course_user) {
        $data = new \stdClass;

        $user = IvsHelper::getUser($course_user->id);

        $data->fullname = $user['fullname'];
        $data->id = $course_user->id;

        foreach ($answer as $key => $value) {
            if ($value['answers'][1]['user_id'] === $course_user->id) {
                if ($value['answers'][0] == null && $value['answers'][1]['question_data']) {
                    $data->last = $value['answers'][1] !== null ? implode(' ', $value['answers'][1]['question_data']) : '';
                    $data->first = $data->last;
                } else {
                    $data->first = $value['answers'][0] !== null ? implode(' ', $value['answers'][0]['question_data']) : '';
                    $data->last = $value['answers'][1] !== null ? implode(' ', $value['answers'][1]['question_data']) : '';
                }
                break;

            } else {
                $data->first = "-";
                $data->last = "-";
            }
        }

        return $data;
    }

}
